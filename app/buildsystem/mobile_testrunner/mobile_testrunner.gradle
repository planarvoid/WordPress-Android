import groovy.json.JsonOutput

apply from: "$project.ext.buildSrcDir/curl.gradle"

class Package { String name; String location }
class Session { Package application_package; Package test_package; Package[] tools_packages }
class RunConfiguration { String label; String test_runner; Test[] tests }
class Execution { Session session; RunConfiguration run_configuration }
class Run { String id; Integer numTests }

class Test {
  String class_name
  String test_name

  def boolean equals(other) {
    if (!(other instanceof Test)) {
      return false
    }
    def otherTest = (Test) other
    this.class_name.equals(otherTest.class_name) && this.test_name.equals(otherTest.test_name)
  }

  def int hashCode() {
    int hash = 1
    hash = hash * 17 + (class_name == null ? 0 : class_name.hashCode())
    hash = hash * 31 + (test_name == null ? 0 : test_name.hashCode())
    return hash
  }
}

class TestResult {
  String description
  Integer duration
  Boolean result
  Test test

  def boolean equals(other) {
    if (!(other instanceof TestResult)) {
      return false
    }
    def otherTestResult = (TestResult) other
    this.description.equals(otherTestResult.description) && this.duration.equals(otherTestResult.duration) && this.result.equals(otherTestResult.result) && this.test.equals(otherTestResult.test)
  }

  def int hashCode() {
    int hash = 1
    hash = hash * 17 + (description == null ? 0 : description.hashCode())
    hash = hash * 31 + (duration == null ? 0 : duration.hashCode())
    hash = hash * 53 + (result == null ? 0 : result.hashCode())
    hash = hash * 79 + (test == null ? 0 : test.hashCode())
    return hash
  }

  def consolePrint() {
    def red = "\u001B[31m"
    def green = "\u001B[32m"
    def reset = "\u001B[0m"
    def color = result ? green : red
    def passed = result ? "PASSED" : "FAILED"
    println "$color$passed: $test.class_name.$test.test_name $reset"
    if (!result) {
      println()
      description.split("\n").each{ println "$color \t$it $reset" }
    }
  }
}

def executeSpecificTestsForLabel(execution) {
  def url = "$project.ext.mobileTestRunnerUrl/devices/android/tests"
  def json_execution = JsonOutput.toJson(execution)
  executePostWithData(url, json_execution, "")
}

def executeQueryForResult(runId) {
  def url = "$project.ext.mobileTestRunnerUrl/results/$runId/no_grouping"
  executeGet(url, [])
}

def parseQueryForResultResponse(response) {
  response.collect { new TestResult(description: it.description, duration: it.duration, result: it.result, test: new Test(class_name: it.test.class_name, test_name: it.test.test_name)) }
}

def copyApkToServer(local_file_path) {
    def remote_filename = UUID.randomUUID().toString() + ".apk"
    def remote_filepath = "/tmp/mobile-testrunner/" + remote_filename
    def remote_host = "$project.ext.mobileTestRunnerUser@$project.ext.mobileTestRunnerHost"

    def cmd = ['scp', local_file_path, "$remote_host:$remote_filepath"]

    def p = cmd.execute()
    p.waitFor()
    def exitValue = p.exitValue()
    if (exitValue != 0) {
        throw new GradleException("copyToServer failed: ($cmd) exitValue: $exitValue")
    }

    remote_filepath
}

def createExecution(String label) {
  def applicationPackage = new Package(name: project.ext.applicationId, location: copyApkToServer(project.ext.apkPath))

  def testPackage = new Package(name: project.ext.testApplicationId, location: copyApkToServer(project.ext.testApkPath))

  def toolsPackages = [new Package(name: project.ext.androidNetorkManagerApplicationId, location: project.ext.networkManagerApkPath)]

  def session = new Session(application_package: applicationPackage, test_package: testPackage, tools_packages: toolsPackages)

  def tests = [new Test(class_name: "com.soundcloud.android.tests.FailureTest", test_name: "testShouldAlwaysFail"),
               new Test(class_name: "com.soundcloud.android.tests.widget.WidgetLinksTest", test_name: "testOpenAppFromWidgetWithUserShowsStreamScreen")]
  def runConfiguration = new RunConfiguration(label: label, test_runner: project.ext.testInstrumentationRunner, tests: tests)

  new Execution(session: session, run_configuration: runConfiguration)
}

def execute(Execution execution) {
  def r = executeSpecificTestsForLabel(execution)
  def runId = r.id
  def numTests = r.num_tests
  println "Executing $numTests test(s) with run id $runId"
  new Run(id: runId, numTests: numTests)
}

def TestResult[] getAndShowResultsForRun(Run run) {
  def retrievedResults = []

  while( retrievedResults.size < run.numTests ) {
    def result = executeQueryForResult(run.id)
    def allResults = parseQueryForResultResponse(result)
    def newResults = allResults - retrievedResults
    retrievedResults = (retrievedResults + allResults).unique()

    newResults.forEach{ it.consolePrint() }

    sleep(500)
  }

  retrievedResults
}

def failBuildIfNecessary(TestResult[] retrievedResults) {
  def failedTests = retrievedResults.count{ (!it.result) }

  if (failedTests > 0) {
    def red = "\u001B[31m"
    def reset = "\u001B[0m"
    throw new GradleException("$red$failedTests test(s) failed $reset")
  }
}

def runTestsForLabel(String label) {
  def run = execute(createExecution(label))
  def results = getAndShowResultsForRun(run)
  failBuildIfNecessary(results)
}

task lollipop << {
  runTestsForLabel("Lollipop")
}

task kitkat << {
  runTestsForLabel("KitKat")
}
