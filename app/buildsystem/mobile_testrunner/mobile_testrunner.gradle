import groovy.json.JsonOutput

apply from: "$project.ext.buildSrcDir/curl.gradle"

class Package { String name; String location }
class Session { Package application_package; Package test_package; Package[] tools_packages }
class RunConfiguration { String label; String test_runner; Test[] tests; String[] only_with_annotations; String[] exclude_annotations}
class Execution { Session session; RunConfiguration run_configuration }
class Run { String id; Integer numTests }

class Test {
  String class_name
  String test_name

  def boolean equals(other) {
    if (!(other instanceof Test)) {
      return false
    }
    def otherTest = (Test) other
    this.class_name.equals(otherTest.class_name) && this.test_name.equals(otherTest.test_name)
  }

  def int hashCode() {
    int hash = 1
    hash = hash * 17 + (class_name == null ? 0 : class_name.hashCode())
    hash = hash * 31 + (test_name == null ? 0 : test_name.hashCode())
    return hash
  }
}

class TestResult {
  String description
  Integer duration
  Boolean result
  Test test

  def boolean equals(other) {
    if (!(other instanceof TestResult)) {
      return false
    }
    def otherTestResult = (TestResult) other
    this.description.equals(otherTestResult.description) && this.duration.equals(otherTestResult.duration) && this.result.equals(otherTestResult.result) && this.test.equals(otherTestResult.test)
  }

  def int hashCode() {
    int hash = 1
    hash = hash * 17 + (description == null ? 0 : description.hashCode())
    hash = hash * 31 + (duration == null ? 0 : duration.hashCode())
    hash = hash * 53 + (result == null ? 0 : result.hashCode())
    hash = hash * 79 + (test == null ? 0 : test.hashCode())
    return hash
  }

  def consolePrint() {
    def red = "\u001B[31m"
    def green = "\u001B[32m"
    def reset = "\u001B[0m"
    def color = result ? green : red
    def passed = result ? "PASSED" : "FAILED"
    println "$color$passed: $test.class_name.$test.test_name $reset"
    if (!result) {
      println()
      description.split("\n").each{ println "$color \t$it $reset" }
    }
  }
}

def executeSpecificTestsForLabel(execution) {
  def url = "$project.ext.mobileTestRunnerUrl/devices/android/tests"
  def json_execution = JsonOutput.toJson(execution)
  executePostWithData(url, json_execution, "")
}

def executeQueryForResult(runId) {
  def url = "$project.ext.mobileTestRunnerUrl/results/$runId/no_grouping"
  executeGet(url, [])
}

def parseQueryForResultResponse(response) {
  response.collect { new TestResult(description: it.description, duration: it.duration, result: it.result, test: new Test(class_name: it.test.class_name, test_name: it.test.test_name)) }
}

def copyApkToServer(local_file_path) {
    def remote_filename = UUID.randomUUID().toString() + ".apk"
    def remote_filepath = "/tmp/mobile-testrunner/" + remote_filename
    def remote_host = "$project.ext.mobileTestRunnerUser@$project.ext.mobileTestRunnerHost"

    def cmd = ['scp', local_file_path, "$remote_host:$remote_filepath"]

    def p = cmd.execute()
    p.waitFor()
    def exitValue = p.exitValue()
    if (exitValue != 0) {
        throw new GradleException("copyToServer failed: ($cmd) exitValue: $exitValue")
    }

    remote_filepath
}

def createSession() {
    def applicationPackage = new Package(name: project.ext.applicationId, location: copyApkToServer(project.ext.apkPath))
    def testPackage = new Package(name: project.ext.testApplicationId, location: copyApkToServer(project.ext.testApkPath))
    def toolsPackages = [new Package(name: project.ext.androidNetorkManagerApplicationId, location: project.ext.networkManagerApkPath)]
    new Session(application_package: applicationPackage, test_package: testPackage, tools_packages: toolsPackages)
}

def createRunConfiguration(String label, String[] onlyWithAnnotations, String[] excludeAnnotations, Test[] specificTests) {
    new RunConfiguration(label: label, test_runner: project.ext.testInstrumentationRunner,
            only_with_annotations: onlyWithAnnotations, exclude_annotations: excludeAnnotations, tests: specificTests)
}

def execute(Execution execution) {
  Logger.getLogger().log("Collecting test infomration")
  def r = executeSpecificTestsForLabel(execution)
  def runId = r.id
  def numTests = r.num_tests
  Logger.getLogger().log("Executing $numTests test(s) with run id $runId")
  new Run(id: runId, numTests: numTests)
}

def TestResult[] getAndShowResultsForRun(Run run) {
  def retrievedResults = []

  while( retrievedResults.size < run.numTests ) {
    def result = executeQueryForResult(run.id)
    def allResults = parseQueryForResultResponse(result)
    def newResults = allResults - retrievedResults
    retrievedResults = (retrievedResults + allResults).unique()

    newResults.forEach{ it.consolePrint() }

    sleep(500)
  }

  retrievedResults
}

def failBuildIfNecessary(TestResult[] retrievedResults) {
  def failedTests = retrievedResults.count{ (!it.result) }

  if (failedTests > 0) {
    def red = "\u001B[31m"
    def reset = "\u001B[0m"
    throw new GradleException("$red$failedTests test(s) failed $reset")
  }
}

def runTestsForLabel(String label, Test[] tests) {
  def execution = new Execution(session: createSession(), run_configuration: createRunConfiguration(label, null, null, tests))
  def run = execute(execution)
  def results = getAndShowResultsForRun(run)
  Logger.getLogger().log("Finished run $run.id")
  failBuildIfNecessary(results)
}


class LogEntry {

    private final long timestamp;
    private final long threadId;
    private final String message;
    public LogEntry(String message) {
        this.timestamp = System.currentTimeMillis()
        this.threadId = Thread.currentThread().getId();
        this.message = message;
    }

    public String toString() {
        timestamp + ": " + message + " [" + threadId + "]"
    }
}

class Logger {
    def logLines = new ArrayList<LogEntry>()

    private def Logger() {}

    def log(String message) {
        def logEntry = new LogEntry(message)
        logLines.add(logEntry)
        println logEntry
    }

    static def Logger logger = null

    static synchronized def getLogger() {
        if (logger == null) {
            logger = new Logger()
        }

        logger
    }
}


task testRunLollipopTests << {
  def tests = [
          new Test(class_name: "com.soundcloud.android.tests.FailureTest", test_name: "testShouldAlwaysFail"),
          new Test(class_name: "com.soundcloud.android.tests.widget.WidgetLinksTest", test_name: "testOpenAppFromWidgetWithUserShowsStreamScreen")
  ] as Test[]

  runTestsForLabel("Lollipop", tests)
}

task runLollipopTests << {
  runTestsForLabel("Lollipop", null)
}

task runKitkatTests << {
  runTestsForLabel("KitKat", null)
}

task stressTestRunner << {
    def r = new Runnable() {
        @Override
        void run() {
            try{
               runTestsForLabel("Lollipop", null)
            } catch(GradleException e) {
                // fail silently
            }
        }
    }

    def threads = []
    10.times {
        def t = new Thread(r)
        t.start()
        threads += t
    }

    threads.each { t -> t.join() }

    def lines = Logger.getLogger().logLines

    def durationMs = lines.last().timestamp - lines.first().timestamp

    def log_filename = "result_stress_test_" + System.currentTimeMillis() + ".log"
    def log = new File(log_filename)

    log.write(lines.join("\n"))

    println("Stress test duration " + durationMs / 1000 + " sec Details in " + log_filename)
}