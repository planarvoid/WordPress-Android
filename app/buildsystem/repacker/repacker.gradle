/**
 * Contains tasks related to shrinking app dependencies, repacking and deploying them.
 *
 * The repacker works by compiling and proguarding the application along a dependency
 * we want to shrink, and generating the repack from the minified classes. This works
 * for JARs and AARs in principle, but custom ProGuard rules might have to be added
 * to proguard-repack.cfg
 *
 * Before repacking anything, make sure the app defines the dependency to the *original*
 * library, so repacking something that had been repacked in the past has to be reverted
 * to the original dependency first.
 *
 * To repack a JAR, run:
 * <code>
 *   $ ./gradlew clean assembleRepackJar repackInstall repackDeploy -P repackProfile=<profile>
 * </code>
 *
 * To repack a AAR, run:
 * <code>
 *   $ ./gradlew clean assembleDebug
 *   $ ./gradlew assembleRepackAar repackInstall repackDeploy -P repackProfile=<profile>
 * </code>
 *
 * Running a normal build first make sure that the AAR has already
 * been extracted into `exploded-aar`, which serves as input for the repacker.
 *
 */
apply plugin: 'maven'

def profiles() {
  [
          "guava": [
                  "base_package": "com/google/common",
                  "group_id"    : "com.google.guava",
                  "artifact_id": "guava",
                  "packaging"  : "jar"
          ],
          "jackson": [
                  "base_package": "com/fasterxml/jackson",
                  "group_id"    : "com.fasterxml.jackson.core",
                  "artifact_id": "jackson",
                  "packaging"  : "jar"
          ],
          "support-v4": [
                  "base_package": "android/support/v4",
                  "group_id"    : "com.android.support",
                  "artifact_id" : "support-v4",
                  "packaging"   : "aar"
          ],
          // TODO: this isn't currently working, since we would have to support merging
          // resource folders on top of class folders.
          "appcompat-v7": [
                  "base_package": "android/support/v7",
                  "group_id"    : "com.android.support",
                  "artifact_id" : "appcompat-v7",
                  "packaging"   : "aar"
          ],
          "facebook": [
                  "base_package": "com/facebook",
                  "group_id": "com.facebook.android",
                  "artifact_id": "facebook-android-sdk",
                  "packaging": "aar"
          ]
  ]
}

def activeProfile() {
  hasProperty("repackProfile") ? profiles()[repackProfile] : null
}

task assembleRepackJar(type: Jar, dependsOn: 'assembleRepack') {
  afterEvaluate {
    if (activeProfile()) {
      String basePackage = activeProfile()['base_package']
      def dependency = findDependency()

      // Find the JAR file of the original dependency, so we can use it for filtering later
      def sourceClassesJar
      if (isAar()) {
        sourceClassesJar = zipTree("${aarDir()}/jars/classes.jar")
      } else {
        def dependencyPath = configurations.compile.find {
          it.path.endsWith("${dependency.name}-${dependency.version}.${repackArtifactPackaging()}")
        }
        sourceClassesJar = zipTree(dependencyPath)
      }

      // from the source JAR, obtain all classes as fully qualified paths
      def sourceClasses = sourceClassesJar.toList().findAll {
        it.name.endsWith(".class")
      }.collect { file ->
        file.path.substring(file.path.indexOf(basePackage))
      }
      assert !sourceClasses.isEmpty()

      destinationDir = file(repackDir())
      archiveName = "classes.jar"

      def source = zipTree("${baseDir()}/classes-proguard/repack/classes.jar")
      // Filter survivors so that only those classes end up in the repack JAR which also exist
      // in the original JAR. This step is necessary since e.g. the Android support libraries
      // have hidden internal impl JARs that end up on the classpath, but are not in the classes.jar
      from source
      include { candidateElem ->
        sourceClasses.any { sourceClassPath ->
          candidateElem.path.endsWith(sourceClassPath)
        }
      }

      // For AARs, we need to copy classes.jar into the exploded-aar dir
      if (isAar()) {
        doLast {
          copy {
            from destinationDir
            include archiveName
            into aarDir()
          }
        }
      }
    }
  }
}

task assembleRepackAar(type: Zip, dependsOn: assembleRepackJar) {
  afterEvaluate {
    if (activeProfile()) {
      extension = "aar"
      destinationDir = file(repackDir())
      from fileTree(aarDir())
      archiveName = "${repackArtifactId()}-${repackArtifactVersion()}.aar"
    }
  }
}

configurations {
  repackJar
  repackAar
}

artifacts {
  repackJar assembleRepackJar
  repackAar assembleRepackAar
}

task repackInstall(type: Upload) {
  afterEvaluate {
    if (activeProfile()) {
      configuration = isAar() ? configurations.repackAar : configurations.repackJar
      repositories {
        mavenInstaller {
          pom.version = repackArtifactVersion()
          pom.artifactId = repackArtifactId()
          pom.groupId = repackArtifactGroupId()
          pom.packaging = repackArtifactPackaging()
        }
      }
    }
  }
  doLast {
    println "-------------------------------------------------------------------"
    println "Repack available at:"
    println artifactCoordinates()
    println "-------------------------------------------------------------------"
  }
}

task repackDeploy(type: Upload) {
  afterEvaluate {
    if (activeProfile()) {
      configuration = isAar() ? configurations.repackAar : configurations.repackJar
      repositories {
        mavenDeployer {
          pom.version = repackArtifactVersion()
          pom.artifactId = repackArtifactId()
          pom.groupId = repackArtifactGroupId()
          pom.packaging = repackArtifactPackaging()
          repository(url: "http://maven.int.s-cloud.net/content/repositories/releases")
          snapshotRepository(url: "http://maven.int.s-cloud.net/content/repositories/snapshots")
        }
      }
    }
  }
}

def baseDir() {
  "${project.buildDir}/intermediates"
}

def repackDir() {
  "${baseDir()}/repacks/${repackArtifactId()}-${repackArtifactVersion()}"
}

def aarDir() {
  def profile = activeProfile()
  String groupId = profile['group_id']
  String artifactId = profile['artifact_id']
  String artifactVersion = sourceVersion()

  "${baseDir()}/exploded-aar/$groupId/$artifactId/$artifactVersion"
}

def repackArtifactVersion() {
  "${sourceVersion()}-${project.ext.versionName}"
}

def sourceVersion() {
  if (hasProperty("sourceVersion")) {
    sourceVersion
  } else {
    findDependency().version
  }
}

def repackArtifactId() {
  activeProfile()['artifact_id'] + "-repack"
}

def repackArtifactGroupId() {
  activeProfile()['group_id']
}

def repackArtifactPackaging() {
  activeProfile()['packaging']
}

def isAar() {
  repackArtifactPackaging() == 'aar'
}

def artifactCoordinates() {
  "${repackArtifactGroupId()}:${repackArtifactId()}:${repackArtifactVersion()}"
}

def findDependency() {
  def profile = activeProfile()
  def dependency = configurations.compile.allDependencies.find {
    it.group == profile['group_id'] && it.name == profile['artifact_id']
  }
  if (!dependency) {
    throw new Exception("Unable to resolve dependency for profile $profile")
  }
  dependency
}
