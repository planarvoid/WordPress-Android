package com.soundcloud.android.memento;

import com.android.tools.lint.client.api.IssueRegistry;
import com.android.tools.lint.detector.api.Issue;
import com.soundcloud.android.memento.utils.Logger;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import org.jetbrains.annotations.Nullable;

import javax.annotation.Generated;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

class MementoCodeGenerator {

    private static final String CLASS_PREFIX = "Memento_";
    private static final String DEFAULT_CLASSNAME = "IssueRegistry";

    static void generate(ProcessingEnvironment environment, @Nullable TypeElement registryElement, List<LintDetectorAnnotatedClass> annotatedFields) {
        final String className = CLASS_PREFIX + getClassName(registryElement);
        final TypeSpec issueRegistry = TypeSpec.classBuilder(className)
                                               .superclass(getSuperClass(registryElement))
                                               .addAnnotation(AnnotationSpec.builder(Generated.class)
                                                                            .addMember("value", "$S", "Generated by MementoProcessor")
                                                                            .build())
                                               .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                                               .addMethod(getIssueMethod(annotatedFields))
                                               .build();
        final String packageName = getPackageName(environment, registryElement, annotatedFields);
        if (packageName == null) {
            Logger.log(environment, "Skipped issue registry generation");
            return;
        }
        final JavaFile file = JavaFile.builder(packageName, issueRegistry).build();
        final Filer filer = environment.getFiler();
        try {
            file.writeTo(filer);
            writeTempManifest(filer, packageName + "." + className);
        } catch (IOException e) {
            Logger.fatalError(environment, "Failed to write %s (%s)", className, e.getMessage());
            e.printStackTrace();
        }
    }

    private static void writeTempManifest(Filer filer, String qualifiedClassName) throws IOException {
        final FileObject fileObject = filer.createResource(StandardLocation.SOURCE_OUTPUT, "", "lint-manifest.txt");
        try (final OutputStream out = fileObject.openOutputStream()) {
            final String registry = "Lint-Registry: " + qualifiedClassName + "\n";
            out.write(registry.getBytes());
        }
    }

    private static TypeName getSuperClass(@Nullable TypeElement registryElement) {
        if (registryElement == null) {
            return TypeName.get(IssueRegistry.class);
        } else {
            return TypeName.get(registryElement.asType());
        }
    }

    private static CharSequence getClassName(@Nullable TypeElement registryElement) {
        if (registryElement == null) {
            return DEFAULT_CLASSNAME;
        } else {
            return registryElement.getSimpleName();
        }
    }

    private static String getPackageName(ProcessingEnvironment environment, @Nullable TypeElement registryElement, List<LintDetectorAnnotatedClass> annotatedFields) {
        final TypeElement element;
        if (registryElement == null) {
            if (annotatedFields.isEmpty()) {
                return null;
            }
            element = annotatedFields.get(0).getElement();
        } else {
            element = registryElement;
        }
        return environment.getElementUtils().getPackageOf(element).getQualifiedName().toString();
    }

    private static MethodSpec getIssueMethod(List<LintDetectorAnnotatedClass> annotatedClasses) {
        return MethodSpec.methodBuilder("getIssues")
                         .addAnnotation(Override.class)
                         .addModifiers(Modifier.PUBLIC)
                         .returns(ParameterizedTypeName.get(List.class, Issue.class))
                         .addCode(buildIssueList(annotatedClasses))
                         .build();
    }

    private static CodeBlock buildIssueList(List<LintDetectorAnnotatedClass> annotatedClasses) {
        CodeBlock.Builder issueList = CodeBlock.builder();
        issueList.addStatement("final $T issues = new $T()", ParameterizedTypeName.get(List.class, Issue.class), ParameterizedTypeName.get(ArrayList.class, Issue.class));
        final int size = annotatedClasses.size();
        for (int i = 0; i < size; i++) {
            LintDetectorAnnotatedClass annotatedClass = annotatedClasses.get(i);
            for (VariableElement element : annotatedClass.getConfigurations()) {
                issueList.addStatement("issues.add($T.$L)", annotatedClass.getElement(), element.getSimpleName());
            }
        }
        issueList.addStatement("return issues", Arrays.class);
        return issueList.build();
    }
}
